<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0070)http://www.eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html -->
<HTML><HEAD><TITLE>Introduction to SWT Graphics</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2800.1106" name=GENERATOR>
<META content=FrontPage.Editor.Document name=ProgId><LINK 
href="SWT_graphics_fichiers/default_style.css" rel=stylesheet></HEAD>
<BODY vLink=#800080 link=#0000ff>
<DIV align=right><FONT size=-2>Copyright © 2003 International Business Machines 
Corp.</FONT> 
<TABLE cellSpacing=0 cellPadding=2 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left bgColor=#0080c0 colSpan=2><B><FONT 
      face=Arial,Helvetica color=#ffffff>&nbsp;Eclipse Corner 
    Article</FONT></B></TD></TR></TBODY></TABLE></DIV>
<H1><IMG height=86 src="SWT_graphics_fichiers/Idea.jpg" width=120 
align=center></H1>
<CENTER>
<H1>Graphics Context - Quick on the draw</H1></CENTER>
<BLOCKQUOTE><B>Summary</B> <BR>The package 
  <CODE>org.eclipse.swt.graphics</CODE> contains classes that allows management 
  of graphics resources. Graphics can be drawn on anything that implements 
  <CODE>org.eclipse.swt.graphics.Drawable, </CODE>which includes 
  <CODE>org.eclipse.swt.widgets.Control</CODE> and 
  <CODE>org.eclipse.swt.graphics.Image</CODE>. The class 
  <CODE>org.eclipse.swt.graphics.GC </CODE>encapsulates all of the drawing API, 
  including how to draw lines and shapes, draw text and images and fill shapes. 
  This article shows how to use a GC to draw onto an Image, or onto a control 
  through its paintEvent callback. The Canvas control, specifically designed for 
  drawing operations, has a number of constructor style bits that allow you to 
  determine when and how painting occurs, and the article shows how to use 
  these. 
  <P><B>By Joe Winchester, IBM</B> <BR>July 3, 2003</P></BLOCKQUOTE>
<HR width="100%">
<BR>Table of contents: 
<UL>
  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Graphics Context">Graphics 
  Context</A> 
  <UL>
    <LI><A 
    href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Graphics Context">Drawing 
    on an Image</A> 
    <LI><A 
    href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Graphics Context">Drawing 
    on a Control</A> </LI></UL>
  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Clipping">Clipping</A> 

  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Canvas">Canvas</A> 

  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Drawing lines and">Drawing 
  lines and shapes</A> 
  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Drawing Text">Drawing 
  text</A> 
  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Filling shapes">Filling 
  shapes</A> 
  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#XOR">XOR</A> 

  <LI><A 
  href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Drawing Images">Drawing 
  images</A> </LI></UL>The SWT graphics system uses the same coordinate convention 
used for controls, where the origin is at 0,0 is the top left corner, and the x 
axis increases to the right while the y axis increases downwards.&nbsp; The 
Point class is used to represent both a location (a position in the coordinate 
system) and also an offset (there is no Dimension class in SWT - the size of a 
rectangle is represented by a Point capturing the x and y offset from its 
origin). 
<H1><A name="Graphics Context"></A>Graphics Context</H1>Graphics can be drawn on 
anything that implements <CODE>org.eclipse.swt.graphics.Drawable</CODE>.&nbsp; 
This includes a Control, an Image, a Display device or a Printer device.&nbsp; 
The class <CODE>org.eclipse.swt.graphics.GC</CODE> is a graphics context that 
encapsulates the drawing operations that can be performed.&nbsp; There are two 
common ways to use a GC; either by creating one using the Drawable instance as a 
constructor argument, or else using a GC that's given to you as part of a 
paintEvent callback. 
<H2>Drawing on an Image</H2>The code below creates a GC with an image as its 
argument and draws two lines on it,&nbsp;<IMG height=13 
src="SWT_graphics_fichiers/tag_1.gif" width=24> one from the top left (0,0) to 
the bottom right, and&nbsp;<IMG height=13 src="SWT_graphics_fichiers/tag_2.gif" 
width=24> one from the top right to the bottom left. 
<P><CODE>&nbsp;&nbsp;&nbsp; Image image = new 
Image(display,"C:/devEclipse_02/eclipse/plugins/org.eclipse.platform_2.0.2/eclipse_lg.gif");</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; GC gc = new GC(image);</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; Rectangle bounds = image.getBounds();</CODE> 
<BR><IMG height=13 src="SWT_graphics_fichiers/tag_1.gif" width=24><CODE> 
gc.drawLine(0,0,bounds.width,bounds.height);</CODE> <BR><IMG height=13 
src="SWT_graphics_fichiers/tag_2.gif" width=24><CODE> 
gc.drawLine(0,bounds.height,bounds.width,0);</CODE> <BR><IMG height=13 
src="SWT_graphics_fichiers/tag_3.gif" width=24><CODE> gc.dispose();</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; image.dispose();</CODE> <BR>&nbsp; 
<TABLE border=1>
  <CAPTION>
  <TBODY><BR></TBODY></CAPTION>
  <TBODY>
  <TR>
    <TD>&nbsp;<I>Original image&nbsp;</I></TD>
    <TD><I>Image after the GC draws across it</I></TD></TR>
  <TR>
    <TD><IMG height=164 src="SWT_graphics_fichiers/image_lg_orig.gif" 
      width=115></TD>
    <TD><IMG height=164 src="SWT_graphics_fichiers/image_lg_lines.gif" 
      width=115></TD></TR></TBODY></TABLE>
<P>When creating a GC you must be responsible for disposing it&nbsp;<IMG 
height=13 src="SWT_graphics_fichiers/tag_3.gif" width=24> by calling its 
dispose() method. For more information on how to manage SWT resources see <A 
href="http://www.eclipse.org/articles/swt-design-2/swt-design-2.html">SWT: The 
Standard Widget Toolkit.</A>&nbsp; A GC that's instantiated by the program 
should be drawn upon and then disposed as soon as possible.&nbsp; This is 
because each GC requires an underlying platform resource, and on some operating 
systems these may be scarce, such as Windows 98 that only allows 5 GC objects to 
be created before it runs out resources. 
<H2>Drawing on a Control</H2>The class 
<CODE>org.eclipse.swt.widgets.Control</CODE> is a Drawable, so you could draw 
onto a Control the same way you draw onto an Image (passing the Control as the 
argument of GC to draw onto it), however unlike drawing on an image (that 
permanently changes the data making up the graphic), if you use a GC to draw 
onto a control you must be aware that when the operating system itself draws the 
control it will overwrite your changes.&nbsp; The correct way to draw onto a 
control is by adding a listener to its paint event.&nbsp; The listener class is 
<CODE>org.eclipse.swt.events.PaintListener</CODE>, and the callback method 
argument is an instance of <CODE>org.eclipse.swt.events.PaintEvent</CODE>.&nbsp; 
The PaintEvent includes a GC that you can send message to, that is already 
prepared to draw onto the control and includes the damaged area. 
<P>The following code&nbsp;<IMG height=13 src="SWT_graphics_fichiers/tag_1.gif" 
width=24> adds a paint listener to a Shell, and in the paintControl callback 
method&nbsp;<IMG height=13 src="SWT_graphics_fichiers/tag_2.gif" width=24> draws 
a line from the origin to bottom right corner. 
<P><CODE>&nbsp;&nbsp;&nbsp; Shell shell = new Shell(display);</CODE> <BR><IMG 
height=13 src="SWT_graphics_fichiers/tag_1.gif" width=24><CODE> 
shell.addPaintListener(new PaintListener(){</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void 
paintControl(PaintEvent e){</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Rectangle clientArea = shell.getClientArea();</CODE> <BR><IMG height=13 
src="SWT_graphics_fichiers/tag_2.gif" 
width=24><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.drawLine(0,0,clientArea.width,clientArea.height);</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; });</CODE> <BR><CODE>&nbsp;&nbsp;&nbsp; 
shell.setSize(150,150)</CODE> 
<P><IMG height=215 src="SWT_graphics_fichiers/ShellDrawnLine.gif" width=267> 
<P>Although the size of the Shell is set to (150,150), the area that can be 
drawn onto is smaller.&nbsp; This is known as the client area, and takes into 
account any trim or borders; for a Shell this includes its edges, titlebar and 
menubar.&nbsp; To determine the clientArea of any Composite use the method 
<CODE>getClientArea().</CODE> 
<P>The application always get a paint event after the underlying OS has drawn 
the control, so any drawing done to the paint event's GC will be shown on top of 
the control.&nbsp; There are some exceptions to this, such as for a ToolBar 
where on certain platforms the items are heavyweight controls that can't be 
drawn on top of, however this is not considered normal behavior.&nbsp; For 
general-purpose drawing the control <CODE><A 
href="http://eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html#Canvas">org.eclipse.swt.widgets.Canvas</A></CODE> 
can be used that is optimized for graphics operations. 
<H1><A name=Clipping></A>Clipping</H1>The clipping area of a GC is the portion 
onto which visible drawing occurs. By default a GC is clipped to the bounds of 
the drawable that it was constructed with. Altering the clipping area of a GC 
allows you to create graphic effects.&nbsp; An example of this is if you wanted 
to fill a triangle shape that had a portion of its edges missing.&nbsp; One way 
to do this would be to draw multiple polygons rectangles making up the shape, 
another way however is to fill the shape, but to clip the GC so that the edges 
are outside the clipping area. 
<P><CODE>&nbsp;&nbsp;&nbsp; shell.addPaintListener(new PaintListener() {</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void 
paintControl(PaintEvent e) {</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Rectangle clientArea = shell.getClientArea();</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
width = clientArea.width;</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
height = clientArea.height;</CODE> <BR><IMG height=13 
src="SWT_graphics_fichiers/tag_2.gif" 
width=24><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.setClipping(20,20,width - 40, height - 40);</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN));</CODE> <BR><IMG 
height=13 src="SWT_graphics_fichiers/tag_1.gif" 
width=24><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.fillPolygon(new int[] {0,0,width,0,width/2,height});</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; });</CODE> 
<P>This code draws a triangle on a Shell as a polygon from&nbsp; the&nbsp;<IMG 
height=13 src="SWT_graphics_fichiers/tag_1.gif" width=24> top left, top right, 
and center of the bottom edge. Beforehand however, the GC is clipped with a 
rectangle&nbsp;<IMG height=13 src="SWT_graphics_fichiers/tag_2.gif" width=24> 
that reduces the client area with a margin of 20 pixels wide, so only the 
clipped rectangle is draw. 
<P><IMG height=191 src="SWT_graphics_fichiers/ClippedTriangles.gif" width=562> 
<P>When a paintEvent occurs for a control the GC is always clipped to just the 
area that needs repainting. For example, if another window is moved in front of 
an SWT shell and then moved away, the newly revealed portion of the GUI is 
marked as damaged and a paint event is queued.&nbsp; When the paint event 
occurs, the <CODE>paintControl(PaintEvent evt)</CODE> method argument contains 
the area of the Control that requires redrawing in its x, y, width and height 
fields.&nbsp; The damage to the control can be complex containing multiple 
disjoint rectangles, and if there is more than one damaged area of a control 
when the paint event occurs the damaged areas are merged into a single rectangle 
representing the union of the damaged areas. This step is performed by the 
underlying platform and is designed to aid performance as multiple paint events 
are processed in a single callback. 
<P>In the example above that fills a clipped triangle&nbsp; each time the 
<CODE>paintControl(PaintEvent)</CODE> method is called, an optimization could be 
to look at the PaintEvent's area.&nbsp; It maybe that the paint event doesn't 
even intersect the shape being drawn in which case no drawing need occur, or if 
only a portion of the drawing is needs repainting then only this is drawn.&nbsp; 
Depending on the type of drawing, working out which portion of a GC to 
selectively redraw however can be more expensive than just relying on the fact 
the GC is clipped, and in practice code inside paint events often just ignores 
the damaged area and re-does all of the GC drawing, relying on clipping to 
ensure only the damaged area is refreshed. 
<P>If a program needs to manually damage an area of a control this can be done 
using <CODE>Control.redraw(int x, int y, int width, int height)</CODE>, or 
<CODE>Control.redraw()</CODE> to damage the entire client area.&nbsp; The area 
is marked as damaged and will be included in the next paint event that 
occurs.&nbsp; To cause a synchronous and immediate paint event to occur use the 
method <CODE>Control.update()</CODE> that will force all outstanding paint 
requests to be processed for the control. If there are no paint request&nbsp; 
(i.e. none of the client area is damaged), then <CODE>update()</CODE> will do 
nothing. 
<H1><A name=Canvas></A>Canvas</H1>Although any Control can be drawn onto through 
its paintEvent, the subclass org.eclipse.swt.widgets.<CODE>Canvas</CODE> is 
specifically designed for graphics operations. This can be done either by using 
a Canvas and adding a paint listener, or through subclassing to create a 
re-usable Custom Control.&nbsp; Canvas has a number of style bits that can be 
used to affect how painting occurs. 
<P>The default behavior for a Canvas is that before it paints itself the entire 
client area is filled with the current background color.&nbsp; This can create 
screen flicker, because if the paintEvent also draws onto the GC, then the user 
sees a flash between the original background being filled, and the drawing 
occurring.&nbsp; One way to avoid this is to use the style bit SWT.NO_BACKGROUND 
when creating the Canvas.&nbsp; This prevents the native background from being 
drawn, however it means the program must be responsible for drawing every pixel 
of the client area. 
<P>When a widget is resized a paint event occurs.&nbsp; This can create screen 
flicker as repeated repainting of the client area occurs.&nbsp; Flicker is also 
known as flash, and the style bit SWT.NO_REDRAW_RESIZE can be used to reduce 
this.&nbsp; When NO_REDRAW_RESIZE is used and the control's size is reduced no 
paint event is generated.&nbsp; This means there will be no flash as the control 
is not unnecessarily redrawn, and if the size is increased then the paint 
event's GC is clipped set to just the area that needs repainting.&nbsp; This is 
the newly revealed bottom and right edge rectangles in a shape like a backwards 
L. 
<P>The style bit NO-REDRAW_RESIZE works well to reduce flicker if a fixed-size 
drawing is being done on the GC, and each newly exposed area generates a paint 
event onto which a fresh piece of the drawing occurs.&nbsp; Incorrectly used 
however, NO_REDRAW_RESIZE can lead to a graphic effect known as cheese.&nbsp; 
Cheese is a general term that applies when a portion of a widget is not updated 
correctly following a resize. An example of&nbsp; is shown below where the paint 
event needs to update the entire client area, such as&nbsp;<IMG height=13 
src="SWT_graphics_fichiers/tag_1.gif" width=24> fill it with an oval 
shape.&nbsp; Because no paint event occurs when the window is reduced in size 
the shape is not redrawn when the size is decreased, and when the window is made 
larger because the GC is clipped to just the damaged area Cheese occurs in the 
newly expanded area because the previous drawing is not erased ( as the paint 
event is clipped to only the newly exposed area ). 
<P><CODE>&nbsp;&nbsp;&nbsp; shell.setLayout(new FillLayout());</CODE> <BR><IMG 
height=13 src="SWT_graphics_fichiers/tag_2.gif" width=24><CODE> final Canvas 
canvas = new Canvas(shell,SWT.NO_REDRAW_RESIZE);</CODE> 
<P><CODE>&nbsp;&nbsp;&nbsp; canvas.addPaintListener(new PaintListener() {</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void 
paintControl(PaintEvent e) {</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Rectangle clientArea = canvas.getClientArea();</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN));</CODE> <BR><IMG 
height=13 src="SWT_graphics_fichiers/tag_1.gif" 
width=24><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
e.gc.fillOval(0,0,clientArea.width,clientArea.height);</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</CODE> 
<BR><CODE>&nbsp;&nbsp;&nbsp; });</CODE> 
<P>When the canvas size is increased the GC is clipped to just the area that 
needs repainting and cheese occurs. 
<P><IMG src="SWT_graphics_fichiers/Cheese_Complete.gif"> 
<P>To correct this problem in line&nbsp;<IMG height=13 
src="SWT_graphics_fichiers/tag_2.gif" width=24> the style bit of SWT.NONE should 
be used so that the GC is not clipped on expansion, and a paint event occurs 
even when the shell size is reduced so the full oval can be repainted. 
<P><IMG height=13 src="SWT_graphics_fichiers/tag_2.gif" width=24><CODE> final 
Canvas canvas = new Canvas(shell,SWT.NONE);</CODE> 
<P>For any SWT widget, if more than one rectangle is damaged then the platform 
merges these into a single damaged area that is the union of all damaged 
rectangles so the SWT program only processes a single paint event. The style bit 
NO_MERGE_PAINTS on Canvas can be used to override this behavior which means the 
listener will be called with a single paint event for every separate damaged 
rectangle. 
<P>The style bits NO_BACKGROUND, NO_REDRAW_RESIZE and NO_MERGE_PAINTS can be 
used with any Composite or subclass, including Canvas, Shell, or Group.&nbsp; 
Although this is allowed by SWT ( no exceptions will be thrown ) the Composite 
class's Javadoc includes the following style bit warning <I>"... their behavior 
is undefined if they are used with subclasses of <CODE>Composite</CODE> other 
than <CODE>Canvas</CODE>".&nbsp; </I>The Canvas class is therefore the preferred 
control to use when performing arbitrary drawing operations. 
<P>Another way to reduce flicker is to batch up the drawing that occurs on the 
display by double buffering.&nbsp; Double buffering is a technique where the 
drawing occurs onto a GC that is not the one used on the paintEvent, and the 
contents are then copied across. To do this you can create an Image with the 
same size as the Canvas' client area and then draw onto this with a 
<CODE>GC(Image)</CODE>;&nbsp; The final image is then transferred across to the 
paint event's GC with a single <CODE>drawImage(Image image, int x, int y) 
</CODE>method call.&nbsp; When using this technique be aware that some platforms 
perform native double buffering for you already, so you may in fact be triple 
buffering. 
<H1><A name="Drawing lines and"></A>Drawing lines and shapes</H1>A GC has a 
number of methods that allow lines to be drawn on it, either between two points, 
a series of interconnected points, or a pre-defined shape.&nbsp; Lines are drawn 
in the foreground color of the GC and can be drawn in a number of styles and 
with different thickeness.&nbsp; For a paint event the GC has the same 
attributes as the control that fired the event (foreground / background color 
and font), and the default line style is solid with a width of 1 pixel. 
<H2><CODE>GC.drawLine(int x1, int y1, int x2, int y2);</CODE></H2>Draw a line 
between two points on the drawable surface beginning at x1,y1 and ending at 
x2,y2.&nbsp; The end points are included in the line, and if they are the same 
then a single pixel dot will be drawn. 
<H2><CODE>GC.drawPolyline(int[] pointArray);</CODE></H2>Draw a series of 
interconnecting lines with the int[] representing x and y positions for 
consecutive points.&nbsp; The statement: <BR><CODE>gc.drawPolyline(new int[] { 
25,5,45,45,5,45 });</CODE> <BR>draws a line from 25,5 to 45,45 and then from 
45,45 onto 5,45. 
<P><IMG height=94 src="SWT_graphics_fichiers/PolygonClient.gif" width=161> 
<H2><CODE>GC.drawPolygon(int[] pointArray);</CODE></H2>Similar to 
<CODE>drawPolyline(int[])</CODE> except that the last point is joined to the 
first <BR><CODE>gc.drawPolygon(new int[] { 25,5,45,45,5,45 });</CODE> <BR>This 
draws the three corners of the triangle and, by joining the point at 5,45 with 
25,5 completes the shape by creating a contained area <BR><IMG height=94 
src="SWT_graphics_fichiers/PolygonClient.gif" width=161> 
<H2><CODE>GC.drawRectangle(int x, int y, int width, int height);</CODE></H2>Draw 
a rectangle with the top left corner at x,y with the specified with and height 
<BR><CODE>gc.drawRectangle(5,5,90,45);</CODE> <BR>draws a rectangle with one 
corner at 5,5 and the opposite corner at 95,50; <BR><IMG height=97 
src="SWT_graphics_fichiers/RectangleClient.gif" width=174> 
<P>When a rectangle is drawn the bottom and right edges are drawn and it is 
conceptually similar to lines being drawn between its four corners.&nbsp; As 
well as passing the x,y,width and height as individual arguments the method is 
overloaded so you can pass in the entire Rectangle - 
<CODE>GC.drawRectangle(Rectangle);</CODE> 
<H2><CODE>GC.drawRoundedRectangle(int x, int y, int width, int height, int 
arcWidth, int arcHeight);</CODE></H2>A rounded rectangle differs from a standard 
rectangle in that its corners are rounded.&nbsp; The rounding on each corner can 
be thought of as 1/4 of an oval, and the arcWidth and arcHeight specify the 
width and height of the full oval. 
<BR><CODE>gc.drawRoundedRectangle(5,5,90,45,25,15); </CODE>draws a rounded 
rectangle with a top left corner of 5,5.&nbsp; The figure below shows a zoomed 
picture of the bottom right corner together with an imaginary oval shown with a 
width of 25 and a height of 15 to show how the rounded corner is created from 
1/4 of the oval. 
<P><IMG height=121 src="SWT_graphics_fichiers/RoundedRectangleClient.gif" 
width=449> 
<P>The implementation of the rounded rectangle could be achieved with 4 calls to 
<CODE>drawArc() </CODE>and 4 to <CODE>drawLine(). </CODE>However on some 
platforms such as Windows or Photon there is an optimized platform API that SWT 
uses. 
<H2><CODE>GC.drawOval(int x, int y, int width, int height);</CODE></H2>An oval 
is draw within the rectangle defined by its top left corner (x,y) and its width 
and height.&nbsp; To draw a circle set the width and height to be the same 
value. <BR><CODE>gc.drawOval(5,5,90,45);</CODE> 
<P><IMG height=95 src="SWT_graphics_fichiers/OvalClient.gif" width=188> 
<H2><CODE>GC.drawArc(int x, int y, int width, int height, int startAngle, int 
endAngle);</CODE></H2>An arc is drawn within the area bounded by the rectangle 
whose top left corner is x,y and has the specified width and height.&nbsp; The 
startAngle is on the horizontal x axis, so 0 degrees does not represent North 
but instead can be thought of as pointing East.&nbsp; The arc is drawn 
anticlockwise for the number of degrees specified by the endAngle 
<BR><CODE>gc.drawArc(5,5,90,45,90,200);</CODE> <BR>This draws an arc beginning 
at 90 degrees, which is vertical ( 0 degrees being horizontal ), and the arc 
continues for 200 degrees.&nbsp; The arc does not stop when it reaches the 
endAngle of 200 degrees relative to the 0 axis, rather it stops when it has 
traversed 200 degrees relative to its starting position. 
<P><IMG height=87 src="SWT_graphics_fichiers/ArcClient.gif" width=161> 
<H2><CODE>GC.setLineStyle(int style);</CODE></H2>Lines can be drawn in a number 
of styles that are defined as static constants on the class 
<CODE>org.eclipse.swt.SWT </CODE>beginning LINE_. <BR>&nbsp; 
<TABLE border=1>
  <CAPTION>
  <TBODY><BR></TBODY></CAPTION>
  <TBODY>
  <TR>
    <TD>SWT.LINE_SOLID</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/Line_SOLID.gif" 
  width=292></TD></TR>
  <TR>
    <TD>SWT.LINE_DOT</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/LINE_DOT.gif" 
  width=292></TD></TR>
  <TR>
    <TD>SWT.LINE_DASH</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/LINE_DASH.gif" 
  width=292></TD></TR>
  <TR>
    <TD>SWT.LINE_DASHDOT</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/LINE_DASHDOT.gif" 
    width=292></TD></TR>
  <TR>
    <TD>SWT.LINE_DASHDOTDOT</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/LINE_DASHDOTDOT.gif" 
      width=292></TD></TR></TBODY></TABLE>
<H2><CODE>GC.setLineWidth(int width);</CODE></H2>The default width for a line is 
1 pixel, however this can be changed by setting the lineWidth of the GC. 
<BR>&nbsp; 
<TABLE border=1>
  <CAPTION>
  <TBODY><BR></TBODY></CAPTION>
  <TBODY>
  <TR>
    <TD>gc.setLineWidth(2);</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/Width_2.gif" 
width=292></TD></TR>
  <TR>
    <TD>gc.setLineWidth(4);</TD>
    <TD><IMG height=16 src="SWT_graphics_fichiers/Width_4.gif" 
  width=292></TD></TR></TBODY></TABLE>
<P>Because line styles and width affect all of the draw operations, allowing you 
to achieve effects such as a dotted rectangle or an oval with a thick line. 
<P><CODE>gc.setLineWidth(3);</CODE> <BR><CODE>gc.drawOval(5,5,40,40);</CODE> 
<BR><CODE>gc.setLineWidth(1);</CODE> 
<BR><CODE>gc.setLineStyle(SWT.LINE_DOT);</CODE> 
<BR><CODE>gc.setForeground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.drawRectangle(60,5,60,40);</CODE> 
<P><IMG height=91 src="SWT_graphics_fichiers/LineShapes.gif" width=172> <BR>When 
a property such as a line width, line style or color is changed on a GC this 
affects all subsequent drawing operations.&nbsp; The code snippet above changes 
the width to 3 to draw the oval, but it then changes it back to 1 before drawing 
the dotted blue rectangle.&nbsp; Forgetting to revert values in a GC after 
modifying them is a common bug when doing SWT graphics programming. 
<H1><A name="Drawing Text"></A>Drawing text</H1>Text can be drawn onto a GC, the 
glyphs are drawn in the GC's foreground color and font, and the area it occupies 
is drawn with the GC's background color.&nbsp; To draw text you define its top 
left corner, width and height.&nbsp; There are two sets of methods to draw text, 
the first set of which have <B><CODE>Text</CODE></B> in their method name, and 
will handle line delimiters and tabs and are used to implement an emulated 
Label. The second set of API methods have <B><CODE>String</CODE></B> in their 
method name, and no tab expansion or carriage return processing occurs, and are 
used for more sophisticated controls like the <CODE>StyledText </CODE>used by 
the Eclipse Java editor. 
<H2><CODE>GC.drawText(String text, int x, int y);</CODE></H2><CODE>Font font = 
new Font(display,"Arial",14,SWT.BOLD | SWT.ITALIC);</CODE> <BR><CODE>// 
...</CODE> <BR><CODE>gc.drawText("Hello World",5,5);</CODE> 
<BR><CODE>gc.setForeground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.setFont(font);</CODE> 
<BR><CODE>gc.drawText("Hello\tThere\nWide\tWorld",5,25);</CODE> <BR><CODE>// 
...</CODE> <BR><CODE>font.dispose();</CODE> 
<P><IMG height=108 src="SWT_graphics_fichiers/TextHelloWorld.gif" width=200> 
<P>The drawText API processes the control characters \t as tab \n as a carriage 
return. 
<H2><CODE>GC.drawString(String text, int x, int y);</CODE></H2><CODE>Font font = 
new Font(display,"Arial",14,SWT.BOLD | SWT.ITALIC);</CODE> <BR><CODE>// 
...</CODE> <BR><CODE>gc.drawString("Hello World",5,5);</CODE> 
<BR><CODE>gc.setForeground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.setFont(font);</CODE> 
<BR><CODE>gc.drawString("Hello\tThere\nWide\tWorld",5,25);</CODE> <BR><CODE>// 
...</CODE> <BR><CODE>font.dispose()</CODE> 
<P><IMG height=106 src="SWT_graphics_fichiers/StringHelloWorld.gif" width=304> 
<BR>When drawString is used, the tab and carriage return characters are not 
processed 
<P>The size that a String occupies when it is drawn onto a GC is based on its 
contents and the font of the GC.&nbsp; To determine the area that a String will 
occupy when it is drawn use the methods <CODE>GC.stringExtent(String text), 
</CODE>or<CODE> GC.textExtent(String text). </CODE>These return a Point whose x 
and y are the width and height required to render the String argument. 
<H2><CODE>GC.drawText(String text, int x, int y, boolean 
isTransparent);</CODE></H2>When drawText(String text, int x, int y) is used the 
text is drawn in the GC's current foreground color.&nbsp; If you are drawing on 
top of an area where you want the existing background to show through, then you 
can set the isTransparent argument to true.&nbsp; This is useful if you are 
drawing on top of an image and you don't want the text to obscure the image's 
background. 
<P><CODE>Font font = new Font(display,"Arial",12,SWT.BOLD | SWT.ITALIC);</CODE> 
<BR><CODE>Image image = new 
Image(display,"C:/devEclipse_02/eclipse/plugins/org.eclipse.platform_2.0.2/eclipse_lg.gif");</CODE> 
<BR><CODE>GC gc = new GC(image);</CODE> <BR><CODE>gc.drawText("Hello 
World",5,5);</CODE> <BR><CODE>gc.setFont(font);</CODE> 
<BR><CODE>gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));</CODE> 
<BR><CODE>gc.drawText("Hello World",5,25,true);</CODE> 
<BR><CODE>gc.dispose();</CODE> <BR><CODE>image.dispose();</CODE> 
<BR><CODE>font.dispose();</CODE> 
<P><IMG height=182 src="SWT_graphics_fichiers/TextHelloWorldTransparent.gif" 
width=159> <BR>&nbsp; 
<H2><CODE>GC.drawText(String text, int x, int y, int flags);</CODE></H2>The 
flags are a bitmask of the constants SWT.DRAW_DELIMITER, SWT.DRAW_TAB, 
SWT.DRAW_TRANSPARENT and SWT.DRAW_MNEMONIC.&nbsp; These determine whether or not 
\n is processed as a carriage return, \t as a tab expansion, whether background 
transparency is used, and whether &amp; is processed as a mnemonic or a literal. 

<P><CODE>gc.drawImage(image,0,0);</CODE> 
<BR><CODE>gc.drawText("Hello\t&amp;There\nWide\tWorld",5,5,SWT.DRAW_TRANSPARENT);</CODE> 
<BR><CODE>gc.drawText("Hello\t&amp;There\nWide\tWorld",5,25,SWT.DRAW_DELIMITER | 
SWT.DRAW_TAB | SWT.DRAW_MNEMONIC );</CODE> 
<P><IMG height=166 src="SWT_graphics_fichiers/TextFlags.gif" width=192> 
<BR>&nbsp; <BR>&nbsp; 
<H1><A name="Filling shapes"></A>Filling shapes</H1>Whereas lines are drawn in 
the GC's foreground color, shapes are filled with the GC's background color. 
<H2><CODE>GC.fillPolygon(int[]);</CODE></H2><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.fillPolygon(new int[] { 25,5,45,45,5,45 })</CODE> <BR><IMG 
height=96 src="SWT_graphics_fichiers/PolygonFillClient.gif" width=164> 
<H2><CODE>GC.fillRectangle(int x, int y, int width, int 
height);</CODE></H2><CODE>gc.fillRectangle(5,5,90,45);</CODE> 
<P><IMG height=98 src="SWT_graphics_fichiers/RectangleFillClient.gif" width=165> 

<P>When a rectangle is filled, the bottom and right edges are not 
included.&nbsp; With the code above the origin point 5,5 is included in the 
filled blue rectangle, however the argument rectangle's bottom right corner of 
95,50 (5+90 , 45+5) is outside the filled area.&nbsp; The bottom right corner of 
the filled rectangle is at 94,49.&nbsp; This is unlike the behavior for 
<CODE>drawRectangle(5,5,90,45)</CODE>, where the full shape is outlined so the 
bottom right corner is 95,50. 
<P>To illustrate this, the code below strokes a rectangle whose corners are 5,5 
and 90,45 before filling it in cyan.&nbsp; To ensure that the filling of the 
rectangle doesn't overwrite its drawn outline, the origin is offset to 
6,6.&nbsp; This moves the bottom right corner of the filled rectangle, however 
because it has already excluded the bottom and right edges it only needs to be 
inset by one to not overlap with the drawn rectangle. 
<P><CODE>gc.drawRectangle(5,5,90,45);</CODE> 
<BR><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_CYAN));</CODE> 
<BR><CODE>gc.fillRectangle(6,6,89,44);</CODE> 
<P><IMG height=111 src="SWT_graphics_fichiers/RectangleStrokeFill.gif" 
width=195> 
<H2><CODE>GC.fillRoundedRectangle(int x, int y, int width, int height, int 
arcWidth, int 
arcHeight);</CODE></H2><CODE>gc.fillRoundRectangle(5,5,90,45,25,15);</CODE> 
<P><IMG height=95 src="SWT_graphics_fichiers/RoundedRectangleFilledClient.gif" 
width=166> 
<P>Like the <CODE>GC.fillRectangle(...) </CODE>method, the bottom and right 
edges are excluded from the filled shape so the bottom right corner becomes 
94,49 rather than 95,50. 
<H2><CODE>GC.fillOval(int x, int y, int width, int 
height);</CODE></H2><CODE>gc.fillOval(5,5,90,45);</CODE> 
<P><IMG height=93 src="SWT_graphics_fichiers/OvalFilledClient.gif" width=167 
align=absBottom> 
<P>Like the other fill APIs, the bounding rectangle's bottom right corner is 
inset by one. 
<H2><CODE>GC.fillArc(int x, int y, int widt4h., int height, int startAngle, int 
endAngle);</CODE></H2><CODE>gc.fillArc(5,5,90,45,90,200);</CODE> <BR><IMG 
height=97 src="SWT_graphics_fichiers/ArcFilledClient.gif" width=196> <BR>The 
arguments to the <CODE>fillArc(...)</CODE> method are similar to the 
<CODE>drawArc(...)</CODE>, with the offset from an East axis to begin filling 
and the number of degrees to continue the arc in an anti-clockwise direction. 
However unlike the <CODE>drawArc(...)</CODE> whose bottom right corner of the 
bounding rectangle is the origin offset by the width and height, 
<CODE>fillArc(...)</CODE> follows the same pattern used by the other fill 
methods where the bottom and right edge are excluded and the corner inset by 
one. 
<H2><CODE>GC.fillGradientRectangle(int x, int y, int width. int height, vertical 
boolean);</CODE></H2>This allows a rectangle to be filled with a gradient of 
coloring between the GC's foreground and background color.&nbsp; The gradient 
can either be horizontal or vertical 
<P><CODE>gc.setBackgrouind(display,getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.fillGradientRectangle(5,5,90,45,false);</CODE> 
<P>This creates a horizontal gradient fill starting with the foreground color 
(black) on the left, and finishing with the background color (blue) on the 
right.&nbsp; As with the other fill methods, the bottom and right edges are 
excluded so the bottom right corner becomes inset by 1. 
<P><IMG height=97 src="SWT_graphics_fichiers/GradientFillFalse.gif" width=166> 
<P><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.setForeground(display.getSystemColor(SWT.COLOR_CYAN));</CODE> 
<BR><CODE>gc.fillGradientRectangle(5,5,90,45,true);</CODE> 
<P>The vertical gradient begins at the top with the foreground color (cyan) and 
finishes at the bottom with the blue background color. 
<P><IMG height=100 src="SWT_graphics_fichiers/GradientFillTrue.gif" width=166> 
<H1><A name=XOR></A>XOR</H1>When drawing occurs on a GC you are altering its 
pixel values that make up the graphic on the Drawable surface.&nbsp; If you set 
the GC's XOR mode to true, then what occurs is that for each pixel the red, 
green and blue values of the source being drawn are XOR'd with the existing red, 
green and blue values and the result becomes the new destination pixel. 
<BR>&nbsp; 
<P><CODE>shell.setBackground(display.getSystemColor(SWT.COLOR_WHITE));</CODE> 
<BR><CODE>// ...</CODE> 
<BR><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_BLUE));</CODE> 
<BR><CODE>gc.fillRectangle(5,5,90,45);</CODE> 
<BR><CODE>gc.setXORMode(true);</CODE> 
<BR><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_WHITE));</CODE> 
<BR><CODE>gc.fillRectangle(20,20,50,50);</CODE> 
<BR><CODE>gc.setBackground(display.getSystemColor(SWT.COLOR_RED));</CODE> 
<BR><CODE>gc.fillOval(80,20,50,50);</CODE> 
<P><IMG height=117 src="SWT_graphics_fichiers/XORFills.gif" width=276> 
<P>The filled rectangle has a background color of white (255,255,255).&nbsp; 
When this is drawn over the blue (0,0,255) the XOR'd result is yellow 
(255,255,0).&nbsp; The portion of the rectangle drawn over the white background 
(255,255,255) creates an XOR result of black (0,0,0). The filled oval has a 
background color or red (255,0,0).&nbsp; When this is drawn over blue the 
resulting XOR value is purple (255,0,255), and when it is drawn over white the 
result is cyan (0,255,255); 
<H1><A name="Drawing Images"></A>Drawing Images</H1>The class 
<CODE>org.eclipse.swt.graphics.Image</CODE> represents a graphic that has been 
prepared ready to be displayed on a device such as a Display or Printer.&nbsp; 
The simplest way to create an image is to load it from a recognized file 
format.&nbsp; Supported file formats are GIF, BMP (Windows format bitmap), JPG, 
PNG, and in newer Eclipse releases TIFF. 
<P><CODE>Image image = new 
Image(display,"C:/eclipse/eclipse/plugins/org.eclipse.platform_2.0.2/eclipse_lg.gif");</CODE> 

<H2><CODE>GC.drawImage(Image image, int x, int y);</CODE></H2>Every image has a 
size that is determined by its bounds.&nbsp; For example, the size of the image 
<CODE>eclipse_lg.gif </CODE>is 115,164 and can be determined by using the method 
<CODE>image.getBounds(). </CODE>When an image is drawn it will be shown at the 
width and height defined by its bounds.. 
<P><CODE>gc.drawImage(image,5,5);</CODE> <BR><IMG height=221 
src="SWT_graphics_fichiers/ImageClient.jpg" width=175> 
<H2><CODE>GC.drawImage(Image image, int srcX, int srcY, int srcWidth, int 
srcHeight, int dstX, int dstY, int dstWidth, int dstHeight);</CODE></H2>Images 
can be drawn with different sizes from their original width and height, and also 
portions of images can be drawn. 
<P>The src coordinates are relative to image itself, so to draw the entire image 
use 0,0 and width and height set to the image bound's width and height.&nbsp; 
The dst arguments represent where to draw the image on the GC, and what size to 
draw it at.&nbsp; The original image is 115 by 164, so to stretch it to twice 
the width and half the height use the statement 
<P><CODE>gc.drawImage(image,0,0,115,164,5,5,230,82);</CODE> <BR><IMG height=136 
src="SWT_graphics_fichiers/ImageClientStretched.jpg" width=289> 
<P>Using the src coordinates allows you to specify that you want only a portion 
of the image drawn.&nbsp; For example, if you only want a section from the top 
right area of the image drawn, you can use src coordinates of 20,0 and a width 
and height of 95,82.&nbsp; The code below draws the destination rectangle with 
the same width and height (95,82) as the cropped area, however a different size 
could be used to stretch or shrink the image portion. 
<P><CODE>gc.drawImage(image,20,0,95,82,5,5,95,82);</CODE> 
<P><IMG height=219 src="SWT_graphics_fichiers/ImageClipped.jpg" width=405> 
<P>Other images effects can be achieved, such as transparency, animation and 
alpha channel blending of images.&nbsp; These are outside the scope of this 
article, however I hope to cover these in a future article. 
<H1><A name="Understanding Images"></A>Conclusion</H1>This article has shown how 
a GC can be used to draw lines, text, and to fill shapes.&nbsp; A GC can be 
created by passing the drawable into its constructor, such as an Image, or for a 
Control by using the <CODE>paintEvent</CODE> callback.&nbsp; The API of a GC 
allows lines and shapes to be drawn in its foreground color and filled in its 
background color.&nbsp; The general purpose Canvas control is optimized to allow 
drawing through its <CODE>paintEvent</CODE>, and it has a number of constructor 
style bits to control when paint events occur.&nbsp; GC clipping allows you to 
control the region of the GC that visible drawing occurs on, and when drawing 
different line styles can be used, and text and images can be shown. 
<P><FONT size=-2>Java and all Java-based trademarks and logos are trademarks or 
registered trademarks of Sun Microsystems, Inc. in the United States, other 
countries, or both. </FONT>
<P><FONT size=-2>Other company, product, and service names may be trademarks or 
service marks of others. </FONT></P></BODY></HTML>
